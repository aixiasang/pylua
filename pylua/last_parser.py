# -*- coding: utf-8 -*-
"""
last_parser.py - Lua AST Parser
================================

AST parser based on Lua 5.3 grammar.
Uses tokens generated by lexer to build AST.
"""

from typing import List, Optional, Tuple
from .last import *
from .llex import (
    LexState, SemInfo, Token,
    luaX_next, luaX_lookahead,
    TK_AND, TK_BREAK, TK_DO, TK_ELSE, TK_ELSEIF, TK_END,
    TK_FALSE, TK_FOR, TK_FUNCTION, TK_GOTO, TK_IF, TK_IN,
    TK_LOCAL, TK_NIL, TK_NOT, TK_OR, TK_REPEAT, TK_RETURN,
    TK_THEN, TK_TRUE, TK_UNTIL, TK_WHILE,
    TK_EQ, TK_NE, TK_LE, TK_GE, TK_CONCAT, TK_DOTS, TK_IDIV,
    TK_SHL, TK_SHR, TK_DBCOLON,
    TK_EOS, TK_NAME, TK_INT, TK_FLT, TK_STRING,
    FIRST_RESERVED, EOZ,
)
from .lobject import TString


class ASTParser:
    """Lua AST parser"""
    
    def __init__(self, source: str, name: str = "input"):
        self.source = source
        self.name = name
        self.ls = None
        self._init_lexer()
    
    def _init_lexer(self):
        """Initialize lexer"""
        source_bytes = self.source.encode('utf-8')
        
        self.ls = LexState()
        
        class SimpleZIO:
            def __init__(self, data):
                self.p = data[1:] if data else b''
                self.n = len(data) - 1 if data else 0
        
        self.ls.z = SimpleZIO(source_bytes)
        
        ts = TString()
        ts.data = self.name.encode('utf-8')
        self.ls.source = ts
        
        if source_bytes:
            self.ls.current = source_bytes[0]
        else:
            self.ls.current = EOZ
        
        self.ls.linenumber = 1
        self.ls.lastline = 1
        self.ls.lookahead = Token()
        self.ls.lookahead.token = TK_EOS
        self.ls.t = Token()
        self.ls.t.seminfo = SemInfo()
        self.ls.buff = bytearray()
        
        # Read first token
        self._advance()
    
    def _advance(self):
        """Advance to next token"""
        luaX_next(self.ls)
    
    def _token(self) -> int:
        """Current token"""
        return self.ls.t.token
    
    def _line(self) -> int:
        """Current line number"""
        return self.ls.linenumber
    
    def _check(self, tok: int) -> bool:
        """Check current token"""
        return self._token() == tok
    
    def _accept(self, tok: int) -> bool:
        """Consume token if matched"""
        if self._check(tok):
            self._advance()
            return True
        return False
    
    def _expect(self, tok: int, msg: str = ""):
        """Expect token"""
        if not self._check(tok):
            if not msg:
                msg = f"expected token {tok}, got {self._token()}"
            raise SyntaxError(f"{self.name}:{self._line()}: {msg}")
        self._advance()
    
    def _get_name(self) -> str:
        """Get identifier name"""
        if self._check(TK_NAME):
            name = self.ls.t.seminfo.ts.data.decode() if self.ls.t.seminfo.ts else ""
            self._advance()
            return name
        raise SyntaxError(f"{self.name}:{self._line()}: expected identifier")
    
    def parse(self) -> Chunk:
        """Parse entire program"""
        block = self._parse_block()
        if not self._check(TK_EOS):
            raise SyntaxError(f"{self.name}:{self._line()}: expected end of file")
        return Chunk(block=block, source=self.name, line=1)
    
    def _parse_block(self) -> Block:
        """Parse statement block"""
        line = self._line()
        statements = []
        return_stat = None
        
        while not self._is_block_end():
            if self._check(TK_RETURN):
                return_stat = self._parse_return()
                break
            stmt = self._parse_statement()
            if stmt:
                statements.append(stmt)
        
        return Block(statements=statements, return_stat=return_stat, line=line)
    
    def _is_block_end(self) -> bool:
        """Check if block end"""
        tok = self._token()
        return tok in (TK_ELSE, TK_ELSEIF, TK_END, TK_UNTIL, TK_EOS)
    
    def _parse_statement(self) -> Optional[ASTNode]:
        """Parse statement"""
        line = self._line()
        tok = self._token()
        
        if tok == ord(';'):
            self._advance()
            return EmptyStat(line=line)
        
        elif tok == TK_IF:
            return self._parse_if()
        
        elif tok == TK_WHILE:
            return self._parse_while()
        
        elif tok == TK_DO:
            return self._parse_do()
        
        elif tok == TK_FOR:
            return self._parse_for()
        
        elif tok == TK_REPEAT:
            return self._parse_repeat()
        
        elif tok == TK_FUNCTION:
            return self._parse_function()
        
        elif tok == TK_LOCAL:
            return self._parse_local()
        
        elif tok == TK_DBCOLON:
            return self._parse_label()
        
        elif tok == TK_GOTO:
            return self._parse_goto()
        
        elif tok == TK_BREAK:
            self._advance()
            return BreakStat(line=line)
        
        else:
            # Assignment or function call
            return self._parse_expr_stat()
    
    def _parse_return(self) -> ReturnStat:
        """Parse return statement"""
        line = self._line()
        self._expect(TK_RETURN)
        
        values = []
        if not self._is_block_end() and not self._check(ord(';')):
            values = self._parse_expr_list()
        
        self._accept(ord(';'))
        return ReturnStat(values=values, line=line)
    
    def _parse_if(self) -> IfStat:
        """Parse if statement"""
        line = self._line()
        self._expect(TK_IF)
        
        condition = self._parse_expr()
        self._expect(TK_THEN)
        then_block = self._parse_block()
        
        elseif_clauses = []
        while self._accept(TK_ELSEIF):
            cond = self._parse_expr()
            self._expect(TK_THEN)
            block = self._parse_block()
            elseif_clauses.append((cond, block))
        
        else_block = None
        if self._accept(TK_ELSE):
            else_block = self._parse_block()
        
        self._expect(TK_END)
        
        return IfStat(
            condition=condition,
            then_block=then_block,
            elseif_clauses=elseif_clauses,
            else_block=else_block,
            line=line
        )
    
    def _parse_while(self) -> WhileStat:
        """Parse while statement"""
        line = self._line()
        self._expect(TK_WHILE)
        condition = self._parse_expr()
        self._expect(TK_DO)
        body = self._parse_block()
        self._expect(TK_END)
        return WhileStat(condition=condition, body=body, line=line)
    
    def _parse_do(self) -> DoStat:
        """Parse do statement"""
        line = self._line()
        self._expect(TK_DO)
        body = self._parse_block()
        self._expect(TK_END)
        return DoStat(body=body, line=line)
    
    def _parse_for(self) -> ASTNode:
        """Parse for statement"""
        line = self._line()
        self._expect(TK_FOR)
        name = self._get_name()
        
        if self._check(ord('=')):
            # Numeric for
            return self._parse_for_num(name, line)
        else:
            # Generic for
            return self._parse_for_in(name, line)
    
    def _parse_for_num(self, name: str, line: int) -> ForNumStat:
        """Parse numeric for"""
        self._expect(ord('='))
        start = self._parse_expr()
        self._expect(ord(','))
        stop = self._parse_expr()
        
        step = None
        if self._accept(ord(',')):
            step = self._parse_expr()
        
        self._expect(TK_DO)
        body = self._parse_block()
        self._expect(TK_END)
        
        return ForNumStat(var=name, start=start, stop=stop, step=step, body=body, line=line)
    
    def _parse_for_in(self, first_name: str, line: int) -> ForInStat:
        """Parse generic for"""
        names = [first_name]
        while self._accept(ord(',')):
            names.append(self._get_name())
        
        self._expect(TK_IN)
        exprs = self._parse_expr_list()
        self._expect(TK_DO)
        body = self._parse_block()
        self._expect(TK_END)
        
        return ForInStat(names=names, exprs=exprs, body=body, line=line)
    
    def _parse_repeat(self) -> RepeatStat:
        """Parse repeat statement"""
        line = self._line()
        self._expect(TK_REPEAT)
        body = self._parse_block()
        self._expect(TK_UNTIL)
        condition = self._parse_expr()
        return RepeatStat(body=body, condition=condition, line=line)
    
    def _parse_function(self) -> FuncStat:
        """Parse function declaration"""
        line = self._line()
        self._expect(TK_FUNCTION)
        name = self._parse_func_name()
        body = self._parse_func_body()
        return FuncStat(name=name, body=body, line=line)
    
    def _parse_func_name(self) -> ASTNode:
        """Parse function name"""
        name = Identifier(name=self._get_name(), line=self._line())
        
        while self._check(ord('.')):
            self._advance()
            field = self._get_name()
            name = FieldExpr(table=name, field=field, line=self._line())
        
        if self._check(ord(':')):
            self._advance()
            method = self._get_name()
            name = MethodExpr(table=name, method=method, line=self._line())
        
        return name
    
    def _parse_func_body(self) -> FuncBody:
        """Parse function body"""
        line = self._line()
        self._expect(ord('('))
        
        params = []
        is_vararg = False
        
        if not self._check(ord(')')):
            while True:
                if self._check(TK_NAME):
                    params.append(self._get_name())
                elif self._check(TK_DOTS):
                    self._advance()
                    is_vararg = True
                    break
                else:
                    raise SyntaxError(f"{self.name}:{self._line()}: expected parameter")
                
                if not self._accept(ord(',')):
                    break
        
        self._expect(ord(')'))
        body = self._parse_block()
        self._expect(TK_END)
        
        return FuncBody(params=params, is_vararg=is_vararg, body=body, line=line)
    
    def _parse_local(self) -> ASTNode:
        """Parse local declaration"""
        line = self._line()
        self._expect(TK_LOCAL)
        
        if self._accept(TK_FUNCTION):
            name = self._get_name()
            body = self._parse_func_body()
            return LocalFuncStat(name=name, body=body, line=line)
        else:
            names = [self._get_name()]
            while self._accept(ord(',')):
                names.append(self._get_name())
            
            values = []
            if self._accept(ord('=')):
                values = self._parse_expr_list()
            
            return LocalVarStat(names=names, values=values, line=line)
    
    def _parse_label(self) -> LabelStat:
        """Parse label"""
        line = self._line()
        self._expect(TK_DBCOLON)
        name = self._get_name()
        self._expect(TK_DBCOLON)
        return LabelStat(name=name, line=line)
    
    def _parse_goto(self) -> GotoStat:
        """Parse goto"""
        line = self._line()
        self._expect(TK_GOTO)
        label = self._get_name()
        return GotoStat(label=label, line=line)
    
    def _parse_expr_stat(self) -> ASTNode:
        """Parse expression statement (assignment or call)"""
        line = self._line()
        expr = self._parse_suffixed_expr()
        
        if self._check(ord('=')) or self._check(ord(',')):
            # Assignment
            targets = [expr]
            while self._accept(ord(',')):
                targets.append(self._parse_suffixed_expr())
            
            self._expect(ord('='))
            values = self._parse_expr_list()
            
            return AssignStat(targets=targets, values=values, line=line)
        else:
            # Function call
            if not isinstance(expr, FuncCall):
                raise SyntaxError(f"{self.name}:{self._line()}: syntax error")
            return CallStat(call=expr, line=line)
    
    def _parse_expr_list(self) -> List[ASTNode]:
        """Parse expression list"""
        exprs = [self._parse_expr()]
        while self._accept(ord(',')):
            exprs.append(self._parse_expr())
        return exprs
    
    def _parse_expr(self) -> ASTNode:
        """Parse expression"""
        return self._parse_or_expr()
    
    def _parse_or_expr(self) -> ASTNode:
        """Parse or expression"""
        left = self._parse_and_expr()
        while self._accept(TK_OR):
            right = self._parse_and_expr()
            left = BinaryExpr(op=BinaryOp.OR, left=left, right=right, line=left.line)
        return left
    
    def _parse_and_expr(self) -> ASTNode:
        """Parse and expression"""
        left = self._parse_cmp_expr()
        while self._accept(TK_AND):
            right = self._parse_cmp_expr()
            left = BinaryExpr(op=BinaryOp.AND, left=left, right=right, line=left.line)
        return left
    
    def _parse_cmp_expr(self) -> ASTNode:
        """Parse comparison expression (left-associative, supports chained comparisons)"""
        left = self._parse_bor_expr()
        
        ops = {
            ord('<'): BinaryOp.LT,
            ord('>'): BinaryOp.GT,
            TK_LE: BinaryOp.LE,
            TK_GE: BinaryOp.GE,
            TK_EQ: BinaryOp.EQ,
            TK_NE: BinaryOp.NE,
        }
        
        # Support chained comparison: a == b == c parses as (a == b) == c
        while True:
            tok = self._token()
            if tok in ops:
                self._advance()
                right = self._parse_bor_expr()
                left = BinaryExpr(op=ops[tok], left=left, right=right, line=left.line)
            else:
                break
        
        return left
    
    def _parse_bor_expr(self) -> ASTNode:
        """Parse bitwise or expression"""
        left = self._parse_bxor_expr()
        while self._check(ord('|')):
            self._advance()
            right = self._parse_bxor_expr()
            left = BinaryExpr(op=BinaryOp.BOR, left=left, right=right, line=left.line)
        return left
    
    def _parse_bxor_expr(self) -> ASTNode:
        """Parse bitwise xor expression"""
        left = self._parse_band_expr()
        while self._check(ord('~')):
            # Distinguish between unary ~ and binary ~
            self._advance()
            right = self._parse_band_expr()
            left = BinaryExpr(op=BinaryOp.BXOR, left=left, right=right, line=left.line)
        return left
    
    def _parse_band_expr(self) -> ASTNode:
        """Parse bitwise and expression"""
        left = self._parse_shift_expr()
        while self._check(ord('&')):
            self._advance()
            right = self._parse_shift_expr()
            left = BinaryExpr(op=BinaryOp.BAND, left=left, right=right, line=left.line)
        return left
    
    def _parse_shift_expr(self) -> ASTNode:
        """Parse shift expression"""
        left = self._parse_concat_expr()
        
        while True:
            if self._check(TK_SHL):
                self._advance()
                right = self._parse_concat_expr()
                left = BinaryExpr(op=BinaryOp.SHL, left=left, right=right, line=left.line)
            elif self._check(TK_SHR):
                self._advance()
                right = self._parse_concat_expr()
                left = BinaryExpr(op=BinaryOp.SHR, left=left, right=right, line=left.line)
            else:
                break
        
        return left
    
    def _parse_concat_expr(self) -> ASTNode:
        """Parse concatenation expression (right-associative)"""
        left = self._parse_add_expr()
        
        if self._check(TK_CONCAT):
            self._advance()
            right = self._parse_concat_expr()  # right-associative
            return BinaryExpr(op=BinaryOp.CONCAT, left=left, right=right, line=left.line)
        
        return left
    
    def _parse_add_expr(self) -> ASTNode:
        """Parse addition/subtraction expression"""
        left = self._parse_mul_expr()
        
        while True:
            if self._check(ord('+')):
                self._advance()
                right = self._parse_mul_expr()
                left = BinaryExpr(op=BinaryOp.ADD, left=left, right=right, line=left.line)
            elif self._check(ord('-')):
                self._advance()
                right = self._parse_mul_expr()
                left = BinaryExpr(op=BinaryOp.SUB, left=left, right=right, line=left.line)
            else:
                break
        
        return left
    
    def _parse_mul_expr(self) -> ASTNode:
        """Parse multiplication/division expression"""
        left = self._parse_unary_expr()
        
        while True:
            if self._check(ord('*')):
                self._advance()
                right = self._parse_unary_expr()
                left = BinaryExpr(op=BinaryOp.MUL, left=left, right=right, line=left.line)
            elif self._check(ord('/')):
                self._advance()
                right = self._parse_unary_expr()
                left = BinaryExpr(op=BinaryOp.DIV, left=left, right=right, line=left.line)
            elif self._check(TK_IDIV):
                self._advance()
                right = self._parse_unary_expr()
                left = BinaryExpr(op=BinaryOp.IDIV, left=left, right=right, line=left.line)
            elif self._check(ord('%')):
                self._advance()
                right = self._parse_unary_expr()
                left = BinaryExpr(op=BinaryOp.MOD, left=left, right=right, line=left.line)
            else:
                break
        
        return left
    
    def _parse_unary_expr(self) -> ASTNode:
        """Parse unary expression"""
        line = self._line()
        
        if self._check(TK_NOT):
            self._advance()
            operand = self._parse_unary_expr()
            return UnaryExpr(op=UnaryOp.NOT, operand=operand, line=line)
        elif self._check(ord('-')):
            self._advance()
            operand = self._parse_unary_expr()
            return UnaryExpr(op=UnaryOp.MINUS, operand=operand, line=line)
        elif self._check(ord('#')):
            self._advance()
            operand = self._parse_unary_expr()
            return UnaryExpr(op=UnaryOp.LEN, operand=operand, line=line)
        elif self._check(ord('~')):
            self._advance()
            operand = self._parse_unary_expr()
            return UnaryExpr(op=UnaryOp.BNOT, operand=operand, line=line)
        else:
            return self._parse_pow_expr()
    
    def _parse_pow_expr(self) -> ASTNode:
        """Parse power expression (right-associative)"""
        left = self._parse_suffixed_expr()
        
        if self._check(ord('^')):
            self._advance()
            right = self._parse_unary_expr()  # right-associative, parse unary first
            return BinaryExpr(op=BinaryOp.POW, left=left, right=right, line=left.line)
        
        return left
    
    def _parse_suffix_from(self, expr: ASTNode) -> ASTNode:
        """Continue parsing suffix from given expression"""
        while True:
            line = self._line()
            
            if self._check(ord('.')):
                self._advance()
                field = self._get_name()
                expr = FieldExpr(table=expr, field=field, line=line)
            
            elif self._check(ord('[')):
                self._advance()
                key = self._parse_expr()
                self._expect(ord(']'))
                expr = IndexExpr(table=expr, key=key, line=line)
            
            elif self._check(ord(':')):
                self._advance()
                method = self._get_name()
                args = self._parse_args()
                expr = FuncCall(func=MethodExpr(table=expr, method=method, line=line),
                               args=args, is_method=True, line=line)
            
            elif self._check(ord('(')) or self._check(TK_STRING) or self._check(ord('{')):
                args = self._parse_args()
                expr = FuncCall(func=expr, args=args, is_method=False, line=line)
            
            else:
                break
        
        return expr
    
    def _parse_suffixed_expr(self) -> ASTNode:
        """Parse suffixed expression"""
        expr = self._parse_primary_expr()
        
        while True:
            line = self._line()
            
            if self._check(ord('.')):
                self._advance()
                field = self._get_name()
                expr = FieldExpr(table=expr, field=field, line=line)
            
            elif self._check(ord('[')):
                self._advance()
                key = self._parse_expr()
                self._expect(ord(']'))
                expr = IndexExpr(table=expr, key=key, line=line)
            
            elif self._check(ord(':')):
                self._advance()
                method = self._get_name()
                args = self._parse_args()
                expr = FuncCall(func=MethodExpr(table=expr, method=method, line=line),
                               args=args, is_method=True, line=line)
            
            elif self._check(ord('(')) or self._check(TK_STRING) or self._check(ord('{')):
                args = self._parse_args()
                expr = FuncCall(func=expr, args=args, is_method=False, line=line)
            
            else:
                break
        
        return expr
    
    def _parse_primary_expr(self) -> ASTNode:
        """Parse primary expression"""
        line = self._line()
        tok = self._token()
        
        if tok == ord('('):
            self._advance()
            expr = self._parse_expr()
            self._expect(ord(')'))
            return expr
        
        elif tok == TK_NAME:
            name = self._get_name()
            return Identifier(name=name, line=line)
        
        elif tok == TK_NIL:
            self._advance()
            return NilLiteral(line=line)
        
        elif tok == TK_TRUE:
            self._advance()
            return BoolLiteral(value=True, line=line)
        
        elif tok == TK_FALSE:
            self._advance()
            return BoolLiteral(value=False, line=line)
        
        elif tok == TK_INT:
            value = self.ls.t.seminfo.i
            self._advance()
            return NumberLiteral(value=value, is_integer=True, line=line)
        
        elif tok == TK_FLT:
            value = self.ls.t.seminfo.r
            self._advance()
            return NumberLiteral(value=value, is_integer=False, line=line)
        
        elif tok == TK_STRING:
            value = self.ls.t.seminfo.ts.data.decode() if self.ls.t.seminfo.ts else ""
            self._advance()
            return StringLiteral(value=value, line=line)
        
        elif tok == TK_DOTS:
            self._advance()
            return VarargExpr(line=line)
        
        elif tok == ord('{'):
            return self._parse_table()
        
        elif tok == TK_FUNCTION:
            self._advance()
            body = self._parse_func_body()
            return FuncExpr(body=body, line=line)
        
        else:
            raise SyntaxError(f"{self.name}:{self._line()}: unexpected token {tok}")
    
    def _parse_table(self) -> TableConstructor:
        """Parse table constructor"""
        line = self._line()
        self._expect(ord('{'))
        
        fields = []
        
        while not self._check(ord('}')):
            field = self._parse_table_field()
            fields.append(field)
            
            if not self._accept(ord(',')) and not self._accept(ord(';')):
                break
        
        self._expect(ord('}'))
        return TableConstructor(fields=fields, line=line)
    
    def _parse_table_field(self) -> TableField:
        """Parse table field"""
        line = self._line()
        
        if self._check(ord('[')):
            # [key] = value
            self._advance()
            key = self._parse_expr()
            self._expect(ord(']'))
            self._expect(ord('='))
            value = self._parse_expr()
            return TableField(key=key, value=value, line=line)
        
        elif self._check(TK_NAME):
            # May be name = value or just value
            # Save current name
            name = self.ls.t.seminfo.ts.data.decode() if self.ls.t.seminfo.ts else ""
            
            # Use simple lookahead: advance, check if =, if not then backtrack
            # Since our lexer has lookahead support, use it
            self._advance()  # consume name
            
            if self._check(ord('=')):
                # Is name = value form
                self._advance()  # consume =
                value = self._parse_expr()
                return TableField(key=StringLiteral(value=name, line=line), 
                                 value=value, line=line)
            else:
                # Not assignment form, name itself is the expression
                # Need to re-parse - name was consumed, handle as Identifier
                # Create an Identifier node as value
                id_node = Identifier(name=name, line=line)
                
                # Check for suffix operations (call, index, etc.)
                value = self._parse_suffix_from(id_node)
                return TableField(key=None, value=value, line=line)
        else:
            value = self._parse_expr()
            return TableField(key=None, value=value, line=line)
    
    def _parse_args(self) -> List[ASTNode]:
        """Parse function arguments"""
        line = self._line()
        
        if self._check(ord('(')):
            self._advance()
            if self._check(ord(')')):
                self._advance()
                return []
            args = self._parse_expr_list()
            self._expect(ord(')'))
            return args
        
        elif self._check(TK_STRING):
            value = self.ls.t.seminfo.ts.data.decode() if self.ls.t.seminfo.ts else ""
            self._advance()
            return [StringLiteral(value=value, line=line)]
        
        elif self._check(ord('{')):
            table = self._parse_table()
            return [table]
        
        else:
            raise SyntaxError(f"{self.name}:{self._line()}: function arguments expected")


def parse_lua(source: str, name: str = "input") -> Chunk:
    """Parse Lua source code and return AST"""
    parser = ASTParser(source, name)
    return parser.parse()


def print_ast(source: str, name: str = "input") -> str:
    """Parse and print AST"""
    ast = parse_lua(source, name)
    printer = ASTPrinter()
    return printer.print(ast)
