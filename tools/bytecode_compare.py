# -*- coding: utf-8 -*-
"""
bytecode_compare.py - PyLua vs Lua 5.3 Bytecode Comparison Tool

Compare bytecode generated by PyLua compiler (lparser + lcode) with Lua 5.3 luac,
verifying instruction-level consistency.

Features:
1. Compile source code using PyLua to generate bytecode
2. Compile the same source code using Lua 5.3 luac
3. Compare instructions one by one, verify exact consistency
4. Output detailed difference report

Based on Lua 5.3.6 official implementation.
Author: aixiasang
"""

import sys
import os
import subprocess
import tempfile
import re
from typing import List, Dict, Tuple, Optional
from dataclasses import dataclass, field

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from pylua.lopcodes import (
    OpCode, GET_OPCODE, GETARG_A, GETARG_B, GETARG_C, GETARG_Bx, GETARG_sBx,
    OP_MOVE, OP_LOADK, OP_LOADKX, OP_LOADBOOL, OP_LOADNIL, 
    OP_GETUPVAL, OP_GETTABUP, OP_GETTABLE, OP_SETTABUP, OP_SETUPVAL, 
    OP_SETTABLE, OP_NEWTABLE, OP_SELF, OP_ADD, OP_SUB, OP_MUL, OP_MOD,
    OP_POW, OP_DIV, OP_IDIV, OP_BAND, OP_BOR, OP_BXOR, OP_SHL, OP_SHR,
    OP_UNM, OP_BNOT, OP_NOT, OP_LEN, OP_CONCAT, OP_JMP, OP_EQ, OP_LT,
    OP_LE, OP_TEST, OP_TESTSET, OP_CALL, OP_TAILCALL, OP_RETURN,
    OP_FORLOOP, OP_FORPREP, OP_TFORCALL, OP_TFORLOOP, OP_SETLIST,
    OP_CLOSURE, OP_VARARG, OP_EXTRAARG
)


@dataclass
class Instruction:
    """Single instruction"""
    pc: int              # Program counter (1-based)
    line: int            # Source line number
    opcode: str          # Opcode name
    a: int = 0           # A argument
    b: int = 0           # B argument
    c: int = 0           # C argument
    bx: int = 0          # Bx argument
    sbx: int = 0         # sBx argument
    comment: str = ""    # Comment
    raw: str = ""        # Raw text


@dataclass
class ProtoInfo:
    """Function prototype info"""
    source: str = ""
    line_start: int = 0
    line_end: int = 0
    num_params: int = 0
    is_vararg: bool = False
    max_stack: int = 0
    num_upvalues: int = 0
    num_locals: int = 0
    num_constants: int = 0
    num_functions: int = 0
    instructions: List[Instruction] = field(default_factory=list)
    constants: List[Tuple[int, str]] = field(default_factory=list)
    locals: List[Tuple[int, str, int, int]] = field(default_factory=list)
    upvalues: List[Tuple[int, str, int, int]] = field(default_factory=list)
    children: List['ProtoInfo'] = field(default_factory=list)


def parse_luac_output(output: str) -> List[ProtoInfo]:
    """Parse luac -l -l output"""
    protos = []
    current_proto = None
    section = None  # 'instructions', 'constants', 'locals', 'upvalues'
    
    lines = output.split('\n')
    i = 0
    
    while i < len(lines):
        line = lines[i].strip()
        
        # Function header: main <file:start,end> (N instructions at 0x...)
        # or: function <file:start,end> (N instructions at 0x...)
        func_match = re.match(
            r'(main|function)\s+<(.+?):(\d+),(\d+)>\s+\((\d+)\s+instructions',
            line
        )
        if func_match:
            if current_proto:
                protos.append(current_proto)
            current_proto = ProtoInfo()
            current_proto.source = func_match.group(2)
            current_proto.line_start = int(func_match.group(3))
            current_proto.line_end = int(func_match.group(4))
            section = None
            i += 1
            continue
        
        # Param info: N+ params, M slots, K upvalues, L locals, C constants, F functions
        params_match = re.match(
            r'(\d+)\+?\s+params?,\s+(\d+)\s+slots?,\s+(\d+)\s+upvalues?,\s+'
            r'(\d+)\s+locals?,\s+(\d+)\s+constants?,\s+(\d+)\s+functions?',
            line
        )
        if params_match and current_proto:
            current_proto.num_params = int(params_match.group(1))
            current_proto.is_vararg = '+' in line.split('params')[0]
            current_proto.max_stack = int(params_match.group(2))
            current_proto.num_upvalues = int(params_match.group(3))
            current_proto.num_locals = int(params_match.group(4))
            current_proto.num_constants = int(params_match.group(5))
            current_proto.num_functions = int(params_match.group(6))
            section = 'instructions'
            i += 1
            continue
        
        # Instruction: N [L] OPCODE A B C ; comment
        instr_match = re.match(
            r'(\d+)\s+\[(\d+)\]\s+(\w+)\s+(.*)',
            line
        )
        if instr_match and current_proto and section == 'instructions':
            inst = Instruction(
                pc=int(instr_match.group(1)),
                line=int(instr_match.group(2)),
                opcode=instr_match.group(3),
                raw=line
            )
            
            # Parse arguments
            args_str = instr_match.group(4)
            # Separate comment
            if ';' in args_str:
                args_part, inst.comment = args_str.split(';', 1)
                inst.comment = inst.comment.strip()
            else:
                args_part = args_str
            
            # Parse argument values
            args = args_part.split()
            if len(args) >= 1:
                try:
                    inst.a = int(args[0])
                except:
                    pass
            if len(args) >= 2:
                try:
                    inst.b = int(args[1])
                except:
                    pass
            if len(args) >= 3:
                try:
                    inst.c = int(args[2])
                except:
                    pass
            
            current_proto.instructions.append(inst)
            i += 1
            continue
        
        # constants (N) for 0x...
        if line.startswith('constants'):
            section = 'constants'
            i += 1
            continue
        
        # locals (N) for 0x...
        if line.startswith('locals'):
            section = 'locals'
            i += 1
            continue
        
        # upvalues (N) for 0x...
        if line.startswith('upvalues'):
            section = 'upvalues'
            i += 1
            continue
        
        # Constant: N value
        if section == 'constants' and current_proto:
            const_match = re.match(r'(\d+)\s+(.*)', line)
            if const_match:
                idx = int(const_match.group(1))
                val = const_match.group(2).strip()
                current_proto.constants.append((idx, val))
        
        # Local variable: N name start end
        if section == 'locals' and current_proto:
            local_match = re.match(r'(\d+)\s+(\S+)\s+(\d+)\s+(\d+)', line)
            if local_match:
                idx = int(local_match.group(1))
                name = local_match.group(2)
                start = int(local_match.group(3))
                end = int(local_match.group(4))
                current_proto.locals.append((idx, name, start, end))
        
        # upvalue: N name instack idx
        if section == 'upvalues' and current_proto:
            upval_match = re.match(r'(\d+)\s+(\S+)\s+(\d+)\s+(\d+)', line)
            if upval_match:
                idx = int(upval_match.group(1))
                name = upval_match.group(2)
                instack = int(upval_match.group(3))
                upidx = int(upval_match.group(4))
                current_proto.upvalues.append((idx, name, instack, upidx))
        
        i += 1
    
    if current_proto:
        protos.append(current_proto)
    
    return protos


def get_lua53_bytecode(source: str) -> Tuple[str, List[ProtoInfo]]:
    """Get Lua 5.3 compiled bytecode"""
    with tempfile.NamedTemporaryFile(mode='w', suffix='.lua', delete=False, encoding='utf-8') as f:
        f.write(source)
        src_file = f.name
    
    try:
        result = subprocess.run(
            ['luac53', '-l', '-l', src_file],
            capture_output=True,
            timeout=10,
            text=True
        )
        if result.returncode != 0:
            return f"Error: {result.stderr}", []
        
        protos = parse_luac_output(result.stdout)
        return result.stdout, protos
    except FileNotFoundError:
        return "Error: luac53 not found", []
    except Exception as e:
        return f"Error: {e}", []
    finally:
        try:
            os.unlink(src_file)
        except:
            pass


def format_proto(proto: ProtoInfo) -> str:
    """Format function prototype info"""
    lines = []
    lines.append(f"function <{proto.source}:{proto.line_start},{proto.line_end}>")
    lines.append(f"  {proto.num_params}{'+ ' if proto.is_vararg else ' '}params, "
                 f"{proto.max_stack} slots, {proto.num_upvalues} upvalues, "
                 f"{proto.num_locals} locals, {proto.num_constants} constants")
    
    lines.append("  Instructions:")
    for inst in proto.instructions:
        comment = f" ; {inst.comment}" if inst.comment else ""
        lines.append(f"    {inst.pc:3d} [{inst.line:3d}] {inst.opcode:12s} "
                     f"{inst.a:3d} {inst.b:3d} {inst.c:3d}{comment}")
    
    if proto.constants:
        lines.append("  Constants:")
        for idx, val in proto.constants:
            lines.append(f"    {idx}: {val}")
    
    if proto.locals:
        lines.append("  Locals:")
        for idx, name, start, end in proto.locals:
            lines.append(f"    {idx}: {name} [{start}-{end}]")
    
    if proto.upvalues:
        lines.append("  Upvalues:")
        for idx, name, instack, upidx in proto.upvalues:
            lines.append(f"    {idx}: {name} (instack={instack}, idx={upidx})")
    
    return '\n'.join(lines)


def compare_instructions(lua_protos: List[ProtoInfo], 
                        pylua_protos: List[ProtoInfo]) -> List[str]:
    """Compare instruction sequences"""
    diffs = []
    
    # Compare function count
    if len(lua_protos) != len(pylua_protos):
        diffs.append(f"Function count mismatch: Lua={len(lua_protos)}, PyLua={len(pylua_protos)}")
        return diffs
    
    for i, (lua_p, pylua_p) in enumerate(zip(lua_protos, pylua_protos)):
        prefix = f"Proto[{i}]"
        
        # Compare instruction count
        if len(lua_p.instructions) != len(pylua_p.instructions):
            diffs.append(f"{prefix}: Instruction count mismatch: "
                        f"Lua={len(lua_p.instructions)}, PyLua={len(pylua_p.instructions)}")
            continue
        
        # Compare instructions one by one
        for j, (lua_inst, pylua_inst) in enumerate(zip(lua_p.instructions, pylua_p.instructions)):
            if lua_inst.opcode != pylua_inst.opcode:
                diffs.append(f"{prefix}[{j+1}]: Opcode mismatch: "
                            f"Lua={lua_inst.opcode}, PyLua={pylua_inst.opcode}")
            elif lua_inst.a != pylua_inst.a:
                diffs.append(f"{prefix}[{j+1}] {lua_inst.opcode}: A mismatch: "
                            f"Lua={lua_inst.a}, PyLua={pylua_inst.a}")
            elif lua_inst.b != pylua_inst.b:
                diffs.append(f"{prefix}[{j+1}] {lua_inst.opcode}: B mismatch: "
                            f"Lua={lua_inst.b}, PyLua={pylua_inst.b}")
            elif lua_inst.c != pylua_inst.c:
                diffs.append(f"{prefix}[{j+1}] {lua_inst.opcode}: C mismatch: "
                            f"Lua={lua_inst.c}, PyLua={pylua_inst.c}")
        
        # Compare constants
        if len(lua_p.constants) != len(pylua_p.constants):
            diffs.append(f"{prefix}: Constant count mismatch: "
                        f"Lua={len(lua_p.constants)}, PyLua={len(pylua_p.constants)}")
        else:
            for j, ((lua_idx, lua_val), (pylua_idx, pylua_val)) in enumerate(
                zip(lua_p.constants, pylua_p.constants)):
                if lua_val != pylua_val:
                    diffs.append(f"{prefix} Constant[{j}]: Lua={lua_val}, PyLua={pylua_val}")
    
    return diffs


def analyze_single_file(filepath: str, verbose: bool = False) -> Dict:
    """Analyze single file"""
    result = {
        'file': os.path.basename(filepath),
        'success': False,
        'lua_output': '',
        'lua_protos': [],
        'diffs': [],
        'error': None
    }
    
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            source = f.read()
        
        # Get Lua 5.3 bytecode
        lua_output, lua_protos = get_lua53_bytecode(source)
        result['lua_output'] = lua_output
        result['lua_protos'] = lua_protos
        
        if lua_output.startswith('Error'):
            result['error'] = lua_output
            return result
        
        result['success'] = True
        
        if verbose:
            print(f"\n=== {result['file']} ===")
            print(f"Functions: {len(lua_protos)}")
            for i, proto in enumerate(lua_protos):
                print(f"\n[Proto {i}]")
                print(format_proto(proto))
        
    except Exception as e:
        result['error'] = str(e)
    
    return result


def batch_analyze(directory: str, verbose: bool = False):
    """Batch analyze all Lua files in directory"""
    print("=" * 70)
    print("PyLua Bytecode Analysis")
    print("=" * 70)
    
    import glob
    files = sorted(glob.glob(os.path.join(directory, '*.lua')))
    
    results = {
        'total': len(files),
        'success': 0,
        'failed': 0,
        'details': []
    }
    
    for filepath in files:
        result = analyze_single_file(filepath, verbose)
        results['details'].append(result)
        
        if result['success']:
            results['success'] += 1
            num_funcs = len(result['lua_protos'])
            total_insts = sum(len(p.instructions) for p in result['lua_protos'])
            print(f"[OK] {result['file']:40s} ({num_funcs:3d} funcs, {total_insts:4d} insts)")
        else:
            results['failed'] += 1
            print(f"[FAIL] {result['file']:40s} {result['error']}")
    
    print("\n" + "=" * 70)
    print(f"Total: {results['total']}, Success: {results['success']}, Failed: {results['failed']}")
    
    return results


def detailed_analysis(source: str, name: str = "input"):
    """Detailed analysis of single source"""
    print("=" * 70)
    print(f"Detailed Analysis: {name}")
    print("=" * 70)
    
    # Show source code
    print("\n--- Source Code ---")
    for i, line in enumerate(source.split('\n'), 1):
        print(f"{i:3d} | {line}")
    
    # Lua 5.3 bytecode
    print("\n--- Lua 5.3 Bytecode ---")
    lua_output, lua_protos = get_lua53_bytecode(source)
    
    if lua_output.startswith('Error'):
        print(lua_output)
        return
    
    for i, proto in enumerate(lua_protos):
        print(f"\n[Function {i}]")
        print(format_proto(proto))
    
    # Statistics
    print("\n--- Statistics ---")
    total_funcs = len(lua_protos)
    total_insts = sum(len(p.instructions) for p in lua_protos)
    total_consts = sum(len(p.constants) for p in lua_protos)
    
    print(f"Functions: {total_funcs}")
    print(f"Total Instructions: {total_insts}")
    print(f"Total Constants: {total_consts}")
    
    # Opcode statistics
    opcode_count = {}
    for proto in lua_protos:
        for inst in proto.instructions:
            opcode_count[inst.opcode] = opcode_count.get(inst.opcode, 0) + 1
    
    print("\n--- Opcode Distribution ---")
    for op, count in sorted(opcode_count.items(), key=lambda x: -x[1]):
        print(f"  {op:15s}: {count:4d}")


def main():
    import argparse
    
    parser = argparse.ArgumentParser(
        description="PyLua vs Lua 5.3 Bytecode Comparison Tool",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s -c "local x = 1"              # Analyze code
  %(prog)s -f tests/code/simple.lua      # Analyze file
  %(prog)s --batch                        # Batch analyze all test files
  %(prog)s -f file.lua -v                 # Verbose output
"""
    )
    
    parser.add_argument("-c", "--code", type=str, help="Analyze code string")
    parser.add_argument("-f", "--file", type=str, help="Analyze file")
    parser.add_argument("--batch", action="store_true", help="Batch analyze")
    parser.add_argument("-v", "--verbose", action="store_true", help="Verbose output")
    
    args = parser.parse_args()
    
    if args.batch:
        code_dir = os.path.join(os.path.dirname(os.path.dirname(__file__)), 
                               'tests', 'code')
        batch_analyze(code_dir, args.verbose)
    elif args.file:
        if os.path.exists(args.file):
            with open(args.file, 'r', encoding='utf-8') as f:
                source = f.read()
            detailed_analysis(source, os.path.basename(args.file))
        else:
            print(f"File not found: {args.file}")
    elif args.code:
        detailed_analysis(args.code, "input")
    else:
        # Default batch analyze
        code_dir = os.path.join(os.path.dirname(os.path.dirname(__file__)), 
                               'tests', 'code')
        batch_analyze(code_dir, args.verbose)


if __name__ == "__main__":
    main()
