# -*- coding: utf-8 -*-
"""
bytecode_diff.py - PyLua vs Lua 5.3 Bytecode Diff Tool

Compare bytecode generated by PyLua lcode with Lua 5.3 luac.
Verify instruction-level consistency.

Based on Lua 5.3.6 official implementation.
Author: aixiasang
"""

import sys
import os
import subprocess
import tempfile
import re
import glob
from typing import List, Dict, Tuple, Optional
from dataclasses import dataclass, field

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))


@dataclass
class Instruction:
    """Instruction"""
    pc: int
    line: int
    opcode: str
    a: int = 0
    b: int = 0
    c: int = 0
    bx: int = 0
    sbx: int = 0
    raw: int = 0


# Opcodes that use Bx parameter
BX_OPCODES = {'LOADK', 'LOADKX', 'CLOSURE'}
# Opcodes that use sBx parameter
SBX_OPCODES = {'JMP', 'FORLOOP', 'FORPREP', 'TFORLOOP'}
# Opcodes that use RK parameters (B or C may be constant index, shown as negative)
RK_B_OPCODES = {'GETTABLE', 'SETTABLE', 'SETTABUP', 'SELF', 
                'ADD', 'SUB', 'MUL', 'MOD', 'POW', 'DIV', 'IDIV', 
                'BAND', 'BOR', 'BXOR', 'SHL', 'SHR', 'EQ', 'LT', 'LE'}
RK_C_OPCODES = {'GETTABUP', 'SETTABUP', 'GETTABLE', 'SETTABLE', 'SELF', 
                'ADD', 'SUB', 'MUL', 'MOD', 'POW', 'DIV', 'IDIV', 
                'BAND', 'BOR', 'BXOR', 'SHL', 'SHR', 'EQ', 'LT', 'LE'}
# Opcodes that use only A C parameters (no B)
AC_OPCODES = {'TFORCALL', 'TEST'}


def rk_to_index(val: int) -> int:
    """Convert luac displayed RK value to actual value
    
    luac display:
    - Positive number means register
    - Negative number means constant index (-1 = const0, -2 = const1, ...)
    
    Actual storage:
    - 0-255 means register
    - 256+ means constant index (256 = const0, 257 = const1, ...)
    """
    if val < 0:
        return 256 + (-val - 1)
    return val


def get_lua53_instructions(source: str) -> Tuple[List[Instruction], str]:
    """Get instruction list from Lua 5.3 luac"""
    with tempfile.NamedTemporaryFile(mode='w', suffix='.lua', 
                                     delete=False, encoding='utf-8') as f:
        f.write(source)
        src_file = f.name
    
    try:
        result = subprocess.run(
            ['luac53', '-l', '-l', src_file],
            capture_output=True,
            timeout=10,
            text=True
        )
        
        if result.returncode != 0:
            return [], result.stderr
        
        instructions = []
        for line in result.stdout.split('\n'):
            # Parse instruction line: \tN\t[L]\tOPCODE\tA B C ...
            match = re.match(r'\s*(\d+)\s+\[(\d+)\]\s+(\w+)\s+(.*)', line)
            if match:
                pc = int(match.group(1))
                ln = int(match.group(2))
                opcode = match.group(3)
                args_str = match.group(4)
                
                # Separate comment
                if ';' in args_str:
                    args_str = args_str.split(';')[0]
                
                args = args_str.split()
                
                inst = Instruction(pc=pc, line=ln, opcode=opcode)
                
                # Parse A argument (all instructions have it)
                if len(args) > 0 and args[0].lstrip('-').isdigit():
                    inst.a = int(args[0])
                
                # Parse other arguments based on instruction type
                if opcode in BX_OPCODES:
                    # Bx format: A Bx (luac shows negative for constant index, -1 = index0)
                    if len(args) > 1 and args[1].lstrip('-').isdigit():
                        bx_val = int(args[1])
                        # Convert luac -1, -2, ... to actual index 0, 1, ...
                        if bx_val < 0:
                            inst.bx = -bx_val - 1
                        else:
                            inst.bx = bx_val
                elif opcode in SBX_OPCODES:
                    # sBx format: A sBx
                    if len(args) > 1 and args[1].lstrip('-').isdigit():
                        inst.sbx = int(args[1])
                elif opcode in AC_OPCODES:
                    # AC format (e.g., TFORCALL, TEST): A C (no B)
                    inst.b = 0
                    if len(args) > 1 and args[1].lstrip('-').isdigit():
                        inst.c = int(args[1])
                else:
                    # ABC format
                    if len(args) > 1 and args[1].lstrip('-').isdigit():
                        b_val = int(args[1])
                        # Handle RK parameter
                        if opcode in RK_B_OPCODES:
                            inst.b = rk_to_index(b_val)
                        else:
                            inst.b = b_val
                    if len(args) > 2 and args[2].lstrip('-').isdigit():
                        c_val = int(args[2])
                        # Handle RK parameter
                        if opcode in RK_C_OPCODES:
                            inst.c = rk_to_index(c_val)
                        else:
                            inst.c = c_val
                
                instructions.append(inst)
        
        return instructions, ""
    
    except FileNotFoundError:
        return [], "luac53 not found"
    except Exception as e:
        return [], str(e)
    finally:
        try:
            os.unlink(src_file)
        except:
            pass


def get_pylua_instructions(source: str) -> Tuple[List[Instruction], str]:
    """Get instruction list from PyLua compiler (including all sub-functions)"""
    try:
        from pylua.compile import pylua_compile, OPCODE_NAMES
        from pylua.lopcodes import OpCode
        
        cp, error = pylua_compile(source)
        if error:
            return [], error
        
        if cp is None:
            return [], "No proto compiled"
        
        instructions = []
        
        def extract_all_instructions(proto):
            """Recursively extract all function instructions"""
            for inst in proto.instructions:
                try:
                    op_enum = OpCode(inst.opcode)
                    opname = OPCODE_NAMES.get(op_enum, f"OP_{inst.opcode}")
                except:
                    opname = f"OP_{inst.opcode}"
                
                i = Instruction(
                    pc=inst.pc,
                    line=inst.line,
                    opcode=opname,
                    a=inst.a,
                    raw=inst.raw
                )
                
                if opname in BX_OPCODES:
                    i.bx = inst.bx
                elif opname in SBX_OPCODES:
                    i.sbx = inst.sbx
                else:
                    i.b = inst.b
                    i.c = inst.c
                
                instructions.append(i)
            
            for child in proto.children:
                extract_all_instructions(child)
        
        extract_all_instructions(cp)
        return instructions, ""
    
    except Exception as e:
        import traceback
        return [], f"{e}\n{traceback.format_exc()}"


def compare_instructions(lua_insts: List[Instruction], 
                        pylua_insts: List[Instruction]) -> List[str]:
    """Compare instruction lists, return differences"""
    diffs = []
    
    if len(lua_insts) != len(pylua_insts):
        diffs.append(f"Instruction count: Lua={len(lua_insts)}, PyLua={len(pylua_insts)}")
    
    max_len = max(len(lua_insts), len(pylua_insts))
    
    for i in range(max_len):
        lua_i = lua_insts[i] if i < len(lua_insts) else None
        pylua_i = pylua_insts[i] if i < len(pylua_insts) else None
        
        if lua_i is None:
            diffs.append(f"[{i+1}] PyLua has extra: {pylua_i.opcode}")
            continue
        if pylua_i is None:
            diffs.append(f"[{i+1}] Lua has extra: {lua_i.opcode}")
            continue
        
        # Compare opcode
        if lua_i.opcode != pylua_i.opcode:
            diffs.append(f"[{i+1}] Opcode: Lua={lua_i.opcode}, PyLua={pylua_i.opcode}")
            continue
        
        # Compare argument A (all instructions have it)
        if lua_i.a != pylua_i.a:
            diffs.append(f"[{i+1}] {lua_i.opcode} A: Lua={lua_i.a}, PyLua={pylua_i.a}")
            continue
        
        # Compare arguments based on instruction type
        opcode = lua_i.opcode
        if opcode in BX_OPCODES:
            # Instructions using Bx parameter
            if lua_i.bx != pylua_i.bx:
                diffs.append(f"[{i+1}] {opcode} Bx: Lua={lua_i.bx}, PyLua={pylua_i.bx}")
        elif opcode in SBX_OPCODES:
            # Instructions using sBx parameter
            if lua_i.sbx != pylua_i.sbx:
                diffs.append(f"[{i+1}] {opcode} sBx: Lua={lua_i.sbx}, PyLua={pylua_i.sbx}")
        elif opcode in AC_OPCODES:
            # Instructions using A C parameters
            if lua_i.c != pylua_i.c:
                diffs.append(f"[{i+1}] {opcode} C: Lua={lua_i.c}, PyLua={pylua_i.c}")
        else:
            # Instructions using B, C parameters
            if lua_i.b != pylua_i.b:
                diffs.append(f"[{i+1}] {opcode} B: Lua={lua_i.b}, PyLua={pylua_i.b}")
            elif lua_i.c != pylua_i.c:
                diffs.append(f"[{i+1}] {opcode} C: Lua={lua_i.c}, PyLua={pylua_i.c}")
    
    return diffs


def compare_source(source: str, name: str = "input", verbose: bool = False) -> Dict:
    """Compare single source code"""
    result = {
        'name': name,
        'success': False,
        'lua_insts': [],
        'pylua_insts': [],
        'diffs': [],
        'lua_error': '',
        'pylua_error': ''
    }
    
    # Get Lua 5.3 instructions
    result['lua_insts'], result['lua_error'] = get_lua53_instructions(source)
    if result['lua_error']:
        return result
    
    # Get PyLua instructions
    result['pylua_insts'], result['pylua_error'] = get_pylua_instructions(source)
    if result['pylua_error']:
        return result
    
    # Compare
    result['diffs'] = compare_instructions(result['lua_insts'], result['pylua_insts'])
    result['success'] = len(result['diffs']) == 0
    
    if verbose:
        print(f"\n{'='*60}")
        print(f"Source: {name}")
        print(f"{'='*60}")
        
        print("\nLua 5.3 Instructions:")
        for inst in result['lua_insts']:
            print(f"  {inst.pc:3d} [{inst.line:3d}] {inst.opcode:12s} {inst.a:4d} {inst.b:4d} {inst.c:4d}")
        
        print("\nPyLua Instructions:")
        for inst in result['pylua_insts']:
            print(f"  {inst.pc:3d} [{inst.line:3d}] {inst.opcode:12s} {inst.a:4d} {inst.b:4d} {inst.c:4d}")
        
        if result['diffs']:
            print("\nDifferences:")
            for diff in result['diffs']:
                print(f"  - {diff}")
        else:
            print("\n[MATCH] All instructions identical!")
    
    return result


def batch_compare(directory: str, verbose: bool = False):
    """Batch compare all Lua files in directory"""
    print("=" * 70)
    print("PyLua vs Lua 5.3 Bytecode Comparison")
    print("=" * 70)
    print()
    
    files = sorted(glob.glob(os.path.join(directory, '*.lua')))
    
    stats = {
        'total': len(files),
        'match': 0,
        'mismatch': 0,
        'lua_error': 0,
        'pylua_error': 0,
        'details': []
    }
    
    for filepath in files:
        name = os.path.basename(filepath)
        
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                source = f.read()
        except Exception as e:
            print(f"[ERROR] {name:40s} Read error: {e}")
            continue
        
        result = compare_source(source, name, verbose=False)
        stats['details'].append(result)
        
        if result['lua_error']:
            print(f"[LUA_ERR] {name:40s} {result['lua_error'][:30]}")
            stats['lua_error'] += 1
        elif result['pylua_error']:
            # Show only first line of error
            err_line = result['pylua_error'].split('\n')[0][:50]
            print(f"[PYLUA_ERR] {name:40s} {err_line}")
            stats['pylua_error'] += 1
        elif result['success']:
            print(f"[MATCH] {name:40s} ({len(result['lua_insts'])} insts)")
            stats['match'] += 1
        else:
            print(f"[DIFF] {name:40s} {len(result['diffs'])} differences")
            stats['mismatch'] += 1
            if verbose:
                for diff in result['diffs'][:5]:
                    print(f"        - {diff}")
    
    print("\n" + "=" * 70)
    print("SUMMARY")
    print("=" * 70)
    print(f"Total Files: {stats['total']}")
    print(f"Match:       {stats['match']} ({100*stats['match']/stats['total']:.1f}%)")
    print(f"Mismatch:    {stats['mismatch']}")
    print(f"Lua Error:   {stats['lua_error']}")
    print(f"PyLua Error: {stats['pylua_error']}")
    
    return stats


def test_simple_cases():
    """Test simple cases"""
    print("=" * 70)
    print("Simple Test Cases")
    print("=" * 70)
    
    cases = [
        ("local x = 1", "local var"),
        ("local a, b = 1, 2", "multi local"),
        ("return 1", "return"),
        ("return 1 + 2", "add"),
        ("local x = 1 + 2", "local add"),
        ("print(1)", "call"),
        ("local x = 1; print(x)", "local + call"),
    ]
    
    for source, name in cases:
        result = compare_source(source, name, verbose=True)
        if result['success']:
            print(f"\n>>> {name}: PASS")
        else:
            print(f"\n>>> {name}: FAIL")
            if result['pylua_error']:
                print(f"    PyLua Error: {result['pylua_error'][:100]}")


def main():
    import argparse
    
    parser = argparse.ArgumentParser(
        description="PyLua vs Lua 5.3 Bytecode Diff Tool"
    )
    
    parser.add_argument("-c", "--code", type=str, help="Compare single code")
    parser.add_argument("-f", "--file", type=str, help="Compare single file")
    parser.add_argument("--batch", action="store_true", help="Batch compare all test files")
    parser.add_argument("--test", action="store_true", help="Run simple test cases")
    parser.add_argument("-v", "--verbose", action="store_true", help="Verbose output")
    
    args = parser.parse_args()
    
    if args.test:
        test_simple_cases()
    elif args.batch:
        code_dir = os.path.join(os.path.dirname(os.path.dirname(__file__)), 
                               'tests', 'code')
        batch_compare(code_dir, args.verbose)
    elif args.file:
        if os.path.exists(args.file):
            with open(args.file, 'r', encoding='utf-8') as f:
                source = f.read()
            compare_source(source, os.path.basename(args.file), verbose=True)
        else:
            print(f"File not found: {args.file}")
    elif args.code:
        compare_source(args.code, "input", verbose=True)
    else:
        test_simple_cases()


if __name__ == "__main__":
    main()
